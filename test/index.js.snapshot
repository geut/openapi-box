exports[`basic test > basic test cjs 1`] = `
"/* eslint eslint-comments/no-unlimited-disable: off */\\n/* eslint-disable */\\n// This document was generated automatically by openapi-box\\n\\n/**\\n * @typedef {import('@sinclair/typebox').TSchema} TSchema\\n */\\n\\n/**\\n * @template {TSchema} T\\n * @typedef {import('@sinclair/typebox').Static<T>} Static\\n */\\n\\n/**\\n * @typedef {import('@sinclair/typebox').SchemaOptions} SchemaOptions\\n */\\n\\n/**\\n * @typedef {{\\n *  [Path in keyof typeof schema]: {\\n *    [Method in keyof typeof schema[Path]]: {\\n *      [Prop in keyof typeof schema[Path][Method]]: typeof schema[Path][Method][Prop] extends TSchema ?\\n *        Static<typeof schema[Path][Method][Prop]> :\\n *        undefined\\n *    }\\n *  }\\n * }} SchemaType\\n */\\n\\n/**\\n * @typedef {{\\n *  [ComponentType in keyof typeof _components]: {\\n *    [ComponentName in keyof typeof _components[ComponentType]]: typeof _components[ComponentType][ComponentName] extends TSchema ?\\n *      Static<typeof _components[ComponentType][ComponentName]> :\\n *      undefined\\n *  }\\n * }} ComponentType\\n */\\n\\nconst { Type: T, TypeRegistry, Kind, CloneType } = require('@sinclair/typebox')\\nconst { Value } = require('@sinclair/typebox/value')\\n\\n/**\\n * @template {TSchema[]} T\\n * @typedef {{\\n *  [Kind]: 'UnionOneOf'\\n *  static: { [K in keyof T]: Static<T[K]> }[number]\\n *  oneOf: T\\n * } & TSchema} TUnionOneOf\\n */\\n\\n/**\\n * @template {TSchema[]} T\\n * @param {[...T]} oneOf\\n * @param {SchemaOptions} [options={}]\\n */\\nconst UnionOneOf = (oneOf, options = {}) => {\\n  /**\\n   * Checks if the value matches exactly one schema in the union.\\n   *\\n   * @param {TUnionOneOf<TSchema[]>} schema - The union schema to check against.\\n   * @param {unknown} value - The value to check.\\n   * @returns {boolean} True if the value matches exactly one schema, otherwise false.\\n   */\\n  function UnionOneOfCheck(schema, value) {\\n    return (\\n      1 ===\\n      schema.oneOf.reduce(\\n        (acc, schema) => (Value.Check(schema, value) ? acc + 1 : acc),\\n        0\\n      )\\n    )\\n  }\\n\\n  if (!TypeRegistry.Has('UnionOneOf'))\\n    TypeRegistry.Set('UnionOneOf', UnionOneOfCheck)\\n\\n  return /** @type {TUnionOneOf<T>} */ ({\\n    ...options,\\n    [Kind]: 'UnionOneOf',\\n    oneOf\\n  })\\n}\\n\\n/**\\n * @namespace\\n */\\nconst refs = {}\\nrefs['ComponentsSchemasDef0'] = T.Object({\\n  lat: T.Number(),\\n  long: T.Number()\\n})\\nrefs['ComponentsSchemasDef1'] = T.Array(\\n  T.Object({\\n    title: T.String(),\\n    address: T.String(),\\n    coordinates: CloneType(refs['ComponentsSchemasDef0'])\\n  })\\n)\\n\\nconst schema = {\\n  '/hello': {\\n    GET: {\\n      args: T.Void(),\\n      data: T.Any({ 'x-status-code': '200' }),\\n      error: T.Union([T.Any({ 'x-status-code': 'default' })])\\n    }\\n  },\\n  '/hello-typed': {\\n    GET: {\\n      args: T.Void(),\\n      data: T.Object(\\n        {\\n          hello: T.Boolean()\\n        },\\n        {\\n          'x-status-code': '200',\\n          'x-content-type': 'application/json'\\n        }\\n      ),\\n      error: T.Union([\\n        T.Object(\\n          {\\n            error: T.String()\\n          },\\n          {\\n            'x-status-code': '404',\\n            'x-content-type': 'application/json'\\n          }\\n        )\\n      ])\\n    }\\n  },\\n  '/multiple-content': {\\n    GET: {\\n      args: T.Void(),\\n      data: T.Object(\\n        {\\n          name: T.String()\\n        },\\n        {\\n          'x-status-code': '200',\\n          'x-content-type': 'application/json'\\n        }\\n      ),\\n      error: T.Union([\\n        T.Object(\\n          {\\n            error: T.String()\\n          },\\n          {\\n            'x-status-code': '404',\\n            'x-content-type': 'application/json'\\n          }\\n        )\\n      ])\\n    }\\n  },\\n  '/some-route/{id}': {\\n    POST: {\\n      args: T.Object({\\n        headers: T.Object({\\n          auth: T.String({ 'x-in': 'header' })\\n        }),\\n        params: T.Object({\\n          id: T.String({ 'x-in': 'path' })\\n        }),\\n        query: T.Object({\\n          filter: T.String({ 'x-in': 'query' }),\\n          address: T.Array(T.String(), { 'x-in': 'query' }),\\n          deep: T.Object(\\n            {\\n              deepTitle: T.Optional(T.String())\\n            },\\n            {\\n              'x-in': 'query'\\n            }\\n          )\\n        }),\\n        body: T.Object(\\n          {\\n            human: T.Object({\\n              name: T.String(),\\n              age: T.Optional(T.Number()),\\n              gender: T.Union([T.Literal('batman'), T.Literal('joker')])\\n            }),\\n            address: CloneType(refs['ComponentsSchemasDef1']),\\n            recursive: T.Object(\\n              {},\\n              {\\n                additionalProperties: true\\n              }\\n            )\\n          },\\n          {\\n            'x-content-type': 'application/json'\\n          }\\n        )\\n      }),\\n      data: T.Object(\\n        {\\n          params: T.Object({\\n            id: T.Optional(T.String())\\n          }),\\n          query: T.Object({\\n            filter: T.String(),\\n            address: T.Array(T.String()),\\n            deep: T.Object({\\n              deepTitle: T.String()\\n            })\\n          }),\\n          body: T.Object({\\n            human: T.Object({\\n              name: T.String(),\\n              age: T.Optional(T.Number()),\\n              gender: T.Union([T.Literal('batman'), T.Literal('joker')])\\n            }),\\n            address: CloneType(refs['ComponentsSchemasDef1']),\\n            recursive: T.Object(\\n              {},\\n              {\\n                additionalProperties: true\\n              }\\n            )\\n          })\\n        },\\n        {\\n          'x-status-code': '201',\\n          'x-content-type': 'application/json'\\n        }\\n      ),\\n      error: T.Union([T.Any({ 'x-status-code': 'default' })])\\n    }\\n  }\\n}\\n\\nconst _components = {\\n  schemas: {\\n    'def-0': CloneType(refs['ComponentsSchemasDef0']),\\n    'def-1': CloneType(refs['ComponentsSchemasDef1'])\\n  }\\n}\\n\\nmodule.exports = { schema, components: _components }\\n"
`;

exports[`basic test > esm 1`] = `
"/* eslint eslint-comments/no-unlimited-disable: off */\\n/* eslint-disable */\\n// This document was generated automatically by openapi-box\\n\\n/**\\n * @typedef {import('@sinclair/typebox').TSchema} TSchema\\n */\\n\\n/**\\n * @template {TSchema} T\\n * @typedef {import('@sinclair/typebox').Static<T>} Static\\n */\\n\\n/**\\n * @typedef {import('@sinclair/typebox').SchemaOptions} SchemaOptions\\n */\\n\\n/**\\n * @typedef {{\\n *  [Path in keyof typeof schema]: {\\n *    [Method in keyof typeof schema[Path]]: {\\n *      [Prop in keyof typeof schema[Path][Method]]: typeof schema[Path][Method][Prop] extends TSchema ?\\n *        Static<typeof schema[Path][Method][Prop]> :\\n *        undefined\\n *    }\\n *  }\\n * }} SchemaType\\n */\\n\\n/**\\n * @typedef {{\\n *  [ComponentType in keyof typeof _components]: {\\n *    [ComponentName in keyof typeof _components[ComponentType]]: typeof _components[ComponentType][ComponentName] extends TSchema ?\\n *      Static<typeof _components[ComponentType][ComponentName]> :\\n *      undefined\\n *  }\\n * }} ComponentType\\n */\\n\\nimport { Type as T, TypeRegistry, Kind, CloneType } from '@sinclair/typebox'\\nimport { Value } from '@sinclair/typebox/value'\\n\\n/**\\n * @template {TSchema[]} T\\n * @typedef {{\\n *  [Kind]: 'UnionOneOf'\\n *  static: { [K in keyof T]: Static<T[K]> }[number]\\n *  oneOf: T\\n * } & TSchema} TUnionOneOf\\n */\\n\\n/**\\n * @template {TSchema[]} T\\n * @param {[...T]} oneOf\\n * @param {SchemaOptions} [options={}]\\n */\\nconst UnionOneOf = (oneOf, options = {}) => {\\n  /**\\n   * Checks if the value matches exactly one schema in the union.\\n   *\\n   * @param {TUnionOneOf<TSchema[]>} schema - The union schema to check against.\\n   * @param {unknown} value - The value to check.\\n   * @returns {boolean} True if the value matches exactly one schema, otherwise false.\\n   */\\n  function UnionOneOfCheck(schema, value) {\\n    return (\\n      1 ===\\n      schema.oneOf.reduce(\\n        (acc, schema) => (Value.Check(schema, value) ? acc + 1 : acc),\\n        0\\n      )\\n    )\\n  }\\n\\n  if (!TypeRegistry.Has('UnionOneOf'))\\n    TypeRegistry.Set('UnionOneOf', UnionOneOfCheck)\\n\\n  return /** @type {TUnionOneOf<T>} */ ({\\n    ...options,\\n    [Kind]: 'UnionOneOf',\\n    oneOf\\n  })\\n}\\n\\n/**\\n * @namespace\\n */\\nconst refs = {}\\nrefs['ComponentsSchemasDef0'] = T.Object({\\n  lat: T.Number(),\\n  long: T.Number()\\n})\\nrefs['ComponentsSchemasDef1'] = T.Array(\\n  T.Object({\\n    title: T.String(),\\n    address: T.String(),\\n    coordinates: CloneType(refs['ComponentsSchemasDef0'])\\n  })\\n)\\n\\nconst schema = {\\n  '/hello': {\\n    GET: {\\n      args: T.Void(),\\n      data: T.Any({ 'x-status-code': '200' }),\\n      error: T.Union([T.Any({ 'x-status-code': 'default' })])\\n    }\\n  },\\n  '/hello-typed': {\\n    GET: {\\n      args: T.Void(),\\n      data: T.Object(\\n        {\\n          hello: T.Boolean()\\n        },\\n        {\\n          'x-status-code': '200',\\n          'x-content-type': 'application/json'\\n        }\\n      ),\\n      error: T.Union([\\n        T.Object(\\n          {\\n            error: T.String()\\n          },\\n          {\\n            'x-status-code': '404',\\n            'x-content-type': 'application/json'\\n          }\\n        )\\n      ])\\n    }\\n  },\\n  '/multiple-content': {\\n    GET: {\\n      args: T.Void(),\\n      data: T.Object(\\n        {\\n          name: T.String()\\n        },\\n        {\\n          'x-status-code': '200',\\n          'x-content-type': 'application/json'\\n        }\\n      ),\\n      error: T.Union([\\n        T.Object(\\n          {\\n            error: T.String()\\n          },\\n          {\\n            'x-status-code': '404',\\n            'x-content-type': 'application/json'\\n          }\\n        )\\n      ])\\n    }\\n  },\\n  '/some-route/{id}': {\\n    POST: {\\n      args: T.Object({\\n        headers: T.Object({\\n          auth: T.String({ 'x-in': 'header' })\\n        }),\\n        params: T.Object({\\n          id: T.String({ 'x-in': 'path' })\\n        }),\\n        query: T.Object({\\n          filter: T.String({ 'x-in': 'query' }),\\n          address: T.Array(T.String(), { 'x-in': 'query' }),\\n          deep: T.Object(\\n            {\\n              deepTitle: T.Optional(T.String())\\n            },\\n            {\\n              'x-in': 'query'\\n            }\\n          )\\n        }),\\n        body: T.Object(\\n          {\\n            human: T.Object({\\n              name: T.String(),\\n              age: T.Optional(T.Number()),\\n              gender: T.Union([T.Literal('batman'), T.Literal('joker')])\\n            }),\\n            address: CloneType(refs['ComponentsSchemasDef1']),\\n            recursive: T.Object(\\n              {},\\n              {\\n                additionalProperties: true\\n              }\\n            )\\n          },\\n          {\\n            'x-content-type': 'application/json'\\n          }\\n        )\\n      }),\\n      data: T.Object(\\n        {\\n          params: T.Object({\\n            id: T.Optional(T.String())\\n          }),\\n          query: T.Object({\\n            filter: T.String(),\\n            address: T.Array(T.String()),\\n            deep: T.Object({\\n              deepTitle: T.String()\\n            })\\n          }),\\n          body: T.Object({\\n            human: T.Object({\\n              name: T.String(),\\n              age: T.Optional(T.Number()),\\n              gender: T.Union([T.Literal('batman'), T.Literal('joker')])\\n            }),\\n            address: CloneType(refs['ComponentsSchemasDef1']),\\n            recursive: T.Object(\\n              {},\\n              {\\n                additionalProperties: true\\n              }\\n            )\\n          })\\n        },\\n        {\\n          'x-status-code': '201',\\n          'x-content-type': 'application/json'\\n        }\\n      ),\\n      error: T.Union([T.Any({ 'x-status-code': 'default' })])\\n    }\\n  }\\n}\\n\\nconst _components = {\\n  schemas: {\\n    'def-0': CloneType(refs['ComponentsSchemasDef0']),\\n    'def-1': CloneType(refs['ComponentsSchemasDef1'])\\n  }\\n}\\n\\nexport { schema, _components as components }\\n"
`;

exports[`petstore.json 1`] = `
"/* eslint eslint-comments/no-unlimited-disable: off */\\n/* eslint-disable */\\n// This document was generated automatically by openapi-box\\n\\n/**\\n * @typedef {import('@sinclair/typebox').TSchema} TSchema\\n */\\n\\n/**\\n * @template {TSchema} T\\n * @typedef {import('@sinclair/typebox').Static<T>} Static\\n */\\n\\n/**\\n * @typedef {import('@sinclair/typebox').SchemaOptions} SchemaOptions\\n */\\n\\n/**\\n * @typedef {{\\n *  [Path in keyof typeof schema]: {\\n *    [Method in keyof typeof schema[Path]]: {\\n *      [Prop in keyof typeof schema[Path][Method]]: typeof schema[Path][Method][Prop] extends TSchema ?\\n *        Static<typeof schema[Path][Method][Prop]> :\\n *        undefined\\n *    }\\n *  }\\n * }} SchemaType\\n */\\n\\n/**\\n * @typedef {{\\n *  [ComponentType in keyof typeof _components]: {\\n *    [ComponentName in keyof typeof _components[ComponentType]]: typeof _components[ComponentType][ComponentName] extends TSchema ?\\n *      Static<typeof _components[ComponentType][ComponentName]> :\\n *      undefined\\n *  }\\n * }} ComponentType\\n */\\n\\nimport { Type as T, TypeRegistry, Kind, CloneType } from '@sinclair/typebox'\\nimport { Value } from '@sinclair/typebox/value'\\n\\n/**\\n * @template {TSchema[]} T\\n * @typedef {{\\n *  [Kind]: 'UnionOneOf'\\n *  static: { [K in keyof T]: Static<T[K]> }[number]\\n *  oneOf: T\\n * } & TSchema} TUnionOneOf\\n */\\n\\n/**\\n * @template {TSchema[]} T\\n * @param {[...T]} oneOf\\n * @param {SchemaOptions} [options={}]\\n */\\nconst UnionOneOf = (oneOf, options = {}) => {\\n  /**\\n   * Checks if the value matches exactly one schema in the union.\\n   *\\n   * @param {TUnionOneOf<TSchema[]>} schema - The union schema to check against.\\n   * @param {unknown} value - The value to check.\\n   * @returns {boolean} True if the value matches exactly one schema, otherwise false.\\n   */\\n  function UnionOneOfCheck(schema, value) {\\n    return (\\n      1 ===\\n      schema.oneOf.reduce(\\n        (acc, schema) => (Value.Check(schema, value) ? acc + 1 : acc),\\n        0\\n      )\\n    )\\n  }\\n\\n  if (!TypeRegistry.Has('UnionOneOf'))\\n    TypeRegistry.Set('UnionOneOf', UnionOneOfCheck)\\n\\n  return /** @type {TUnionOneOf<T>} */ ({\\n    ...options,\\n    [Kind]: 'UnionOneOf',\\n    oneOf\\n  })\\n}\\n\\n/**\\n * @namespace\\n */\\nconst refs = {}\\nrefs['ComponentsSchemasError'] = T.Object({\\n  code: T.Integer({ format: 'int32' }),\\n  message: T.String()\\n})\\nrefs['ComponentsSchemasPet'] = T.Object({\\n  id: T.Integer({ format: 'int64' }),\\n  name: T.String(),\\n  tag: T.Optional(T.String())\\n})\\nrefs['ComponentsSchemasPets'] = T.Array(CloneType(refs['ComponentsSchemasPet']))\\n\\nconst schema = {\\n  '/pets': {\\n    GET: {\\n      args: T.Optional(\\n        T.Object({\\n          query: T.Optional(\\n            T.Object({\\n              limit: T.Optional(T.Integer({ format: 'int32', 'x-in': 'query' }))\\n            })\\n          )\\n        })\\n      ),\\n      data: CloneType(refs['ComponentsSchemasPets'], {\\n        'x-status-code': '200',\\n        'x-content-type': 'application/json'\\n      }),\\n      error: T.Union([\\n        CloneType(refs['ComponentsSchemasError'], {\\n          'x-status-code': 'default',\\n          'x-content-type': 'application/json'\\n        })\\n      ])\\n    },\\n    POST: {\\n      args: T.Void(),\\n      data: T.Any({ 'x-status-code': '201' }),\\n      error: T.Union([\\n        CloneType(refs['ComponentsSchemasError'], {\\n          'x-status-code': 'default',\\n          'x-content-type': 'application/json'\\n        })\\n      ])\\n    }\\n  },\\n  '/pets/{petId}': {\\n    GET: {\\n      args: T.Object({\\n        params: T.Object({\\n          petId: T.String({ 'x-in': 'path' })\\n        })\\n      }),\\n      data: CloneType(refs['ComponentsSchemasPet'], {\\n        'x-status-code': '200',\\n        'x-content-type': 'application/json'\\n      }),\\n      error: T.Union([\\n        CloneType(refs['ComponentsSchemasError'], {\\n          'x-status-code': 'default',\\n          'x-content-type': 'application/json'\\n        })\\n      ])\\n    }\\n  }\\n}\\n\\nconst _components = {\\n  parameters: {\\n    skipParam: T.Integer({ format: 'int32', 'x-in': 'query' }),\\n    limitParam: T.Integer({ format: 'int32', 'x-in': 'query' })\\n  },\\n  responses: {\\n    NotFound: T.Any({}),\\n    IllegalInput: T.Any({}),\\n    GeneralError: CloneType(refs['ComponentsSchemasError'], {\\n      'x-content-type': 'application/json'\\n    })\\n  },\\n  requestBodies: {\\n    Pet: CloneType(refs['ComponentsSchemasPet'], {\\n      'x-content-type': 'application/json'\\n    })\\n  },\\n  schemas: {\\n    Error: CloneType(refs['ComponentsSchemasError']),\\n    Pet: CloneType(refs['ComponentsSchemasPet']),\\n    Pets: CloneType(refs['ComponentsSchemasPets'])\\n  }\\n}\\n\\nexport { schema, _components as components }\\n"
`;

exports[`petstore.yaml 1`] = `
"/* eslint eslint-comments/no-unlimited-disable: off */\\n/* eslint-disable */\\n// This document was generated automatically by openapi-box\\n\\n/**\\n * @typedef {import('@sinclair/typebox').TSchema} TSchema\\n */\\n\\n/**\\n * @template {TSchema} T\\n * @typedef {import('@sinclair/typebox').Static<T>} Static\\n */\\n\\n/**\\n * @typedef {import('@sinclair/typebox').SchemaOptions} SchemaOptions\\n */\\n\\n/**\\n * @typedef {{\\n *  [Path in keyof typeof schema]: {\\n *    [Method in keyof typeof schema[Path]]: {\\n *      [Prop in keyof typeof schema[Path][Method]]: typeof schema[Path][Method][Prop] extends TSchema ?\\n *        Static<typeof schema[Path][Method][Prop]> :\\n *        undefined\\n *    }\\n *  }\\n * }} SchemaType\\n */\\n\\n/**\\n * @typedef {{\\n *  [ComponentType in keyof typeof _components]: {\\n *    [ComponentName in keyof typeof _components[ComponentType]]: typeof _components[ComponentType][ComponentName] extends TSchema ?\\n *      Static<typeof _components[ComponentType][ComponentName]> :\\n *      undefined\\n *  }\\n * }} ComponentType\\n */\\n\\nimport { Type as T, TypeRegistry, Kind, CloneType } from '@sinclair/typebox'\\nimport { Value } from '@sinclair/typebox/value'\\n\\n/**\\n * @template {TSchema[]} T\\n * @typedef {{\\n *  [Kind]: 'UnionOneOf'\\n *  static: { [K in keyof T]: Static<T[K]> }[number]\\n *  oneOf: T\\n * } & TSchema} TUnionOneOf\\n */\\n\\n/**\\n * @template {TSchema[]} T\\n * @param {[...T]} oneOf\\n * @param {SchemaOptions} [options={}]\\n */\\nconst UnionOneOf = (oneOf, options = {}) => {\\n  /**\\n   * Checks if the value matches exactly one schema in the union.\\n   *\\n   * @param {TUnionOneOf<TSchema[]>} schema - The union schema to check against.\\n   * @param {unknown} value - The value to check.\\n   * @returns {boolean} True if the value matches exactly one schema, otherwise false.\\n   */\\n  function UnionOneOfCheck(schema, value) {\\n    return (\\n      1 ===\\n      schema.oneOf.reduce(\\n        (acc, schema) => (Value.Check(schema, value) ? acc + 1 : acc),\\n        0\\n      )\\n    )\\n  }\\n\\n  if (!TypeRegistry.Has('UnionOneOf'))\\n    TypeRegistry.Set('UnionOneOf', UnionOneOfCheck)\\n\\n  return /** @type {TUnionOneOf<T>} */ ({\\n    ...options,\\n    [Kind]: 'UnionOneOf',\\n    oneOf\\n  })\\n}\\n\\n/**\\n * @namespace\\n */\\nconst refs = {}\\nrefs['ComponentsSchemasError'] = T.Object({\\n  code: T.Integer({ format: 'int32' }),\\n  message: T.String()\\n})\\nrefs['ComponentsSchemasPet'] = T.Object({\\n  id: T.Integer({ format: 'int64' }),\\n  name: T.String(),\\n  tag: T.Optional(T.String())\\n})\\nrefs['ComponentsSchemasPets'] = T.Array(CloneType(refs['ComponentsSchemasPet']))\\n\\nconst schema = {\\n  '/pets': {\\n    GET: {\\n      args: T.Optional(\\n        T.Object({\\n          query: T.Optional(\\n            T.Object({\\n              limit: T.Optional(T.Integer({ format: 'int32', 'x-in': 'query' }))\\n            })\\n          )\\n        })\\n      ),\\n      data: CloneType(refs['ComponentsSchemasPets'], {\\n        'x-status-code': '200',\\n        'x-content-type': 'application/json'\\n      }),\\n      error: T.Union([\\n        CloneType(refs['ComponentsSchemasError'], {\\n          'x-status-code': 'default',\\n          'x-content-type': 'application/json'\\n        })\\n      ])\\n    },\\n    POST: {\\n      args: T.Void(),\\n      data: T.Any({ 'x-status-code': '201' }),\\n      error: T.Union([\\n        CloneType(refs['ComponentsSchemasError'], {\\n          'x-status-code': 'default',\\n          'x-content-type': 'application/json'\\n        })\\n      ])\\n    }\\n  },\\n  '/pets/{petId}': {\\n    GET: {\\n      args: T.Object({\\n        params: T.Object({\\n          petId: T.String({ 'x-in': 'path' })\\n        })\\n      }),\\n      data: CloneType(refs['ComponentsSchemasPet'], {\\n        'x-status-code': '200',\\n        'x-content-type': 'application/json'\\n      }),\\n      error: T.Union([\\n        CloneType(refs['ComponentsSchemasError'], {\\n          'x-status-code': 'default',\\n          'x-content-type': 'application/json'\\n        })\\n      ])\\n    }\\n  }\\n}\\n\\nconst _components = {\\n  parameters: {\\n    skipParam: T.Integer({ format: 'int32', 'x-in': 'query' }),\\n    limitParam: T.Integer({ format: 'int32', 'x-in': 'query' })\\n  },\\n  responses: {\\n    NotFound: T.Any({}),\\n    IllegalInput: T.Any({}),\\n    GeneralError: CloneType(refs['ComponentsSchemasError'], {\\n      'x-content-type': 'application/json'\\n    })\\n  },\\n  requestBodies: {\\n    Pet: CloneType(refs['ComponentsSchemasPet'], {\\n      'x-content-type': 'application/json'\\n    })\\n  },\\n  schemas: {\\n    Error: CloneType(refs['ComponentsSchemasError']),\\n    Pet: CloneType(refs['ComponentsSchemasPet']),\\n    Pets: CloneType(refs['ComponentsSchemasPets'])\\n  }\\n}\\n\\nexport { schema, _components as components }\\n"
`;
